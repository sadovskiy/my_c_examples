/*
 *
 * Copyright (C) 2020. GPL
 *
 * Written by Sadovskiy B. S.
 *
 *
 * Права на программу (С) 2020. GPL
 *
 * Написана Садовским Б. С.
 *
 * Программа демонстрирует алгоритм пузырьковой сортировки и двоичного поиска.
 * Сортировка на возрастание
 * 
 * Подробнее:
 * https://ru.wikipedia.org/wiki/Сортировка_пузырьком
 * https://ru.wikipedia.org/wiki/Двоичный_поиск
 * 
 * 
 */

#include <stdio.h>

#define SIZE_ARRAY 10

int main(void)
{
    // Исходный массив
    int array[] = {5, 6, 1, 9, 4, 8, 7, 2, 5, 3};

    // Алгоритм работает просто. цикл while заставляет многократно
    // обходить массив и проверяя переменную end.
    // Переменная устанавливается в 0, но если будет найдена хоть одна
    // пара элементов, которую можно поменять местами, то она будет
    // установлена в 1, и цикл будет повторён.
    // цикл for проходит массив и с помощью условия if ищет соседние
    // элементы, которые можно обменять местами и установить
    // переменную end в 1.
    int end = 1; // Для выхода, когда всё будет отсортировано
    while (end) {
        end = 0;
        // SIZE_ARRAY - 1 что бы остановиться на предпоследнем элементе
        // для обмена.
        for (int i = 0; i < SIZE_ARRAY - 1; ++i) {
            // Проверяем какой элемент больше
            if (array[i] > array[i + 1]) { // Если первый больше то меняем
                int temp = array[i];       // их местами через временный
                array[i] = array[i + 1];   // элемент temp
                array[i + 1] = temp;
                end = 1;    // Ставим, что бы ещё раз пройти по массиву
            }               // так как предполагаем наличие ещё
        }                   // неотсортированных элементов
    }

    // После сортировки {0, 1, 2, 3, 4, 5, 5, 6, 7, 9}

    // Выведем массив на экран
    for (int i = 0; i < SIZE_ARRAY; ++i)
        printf("%d ", array[i]);

    printf("\n");

    // Алгоритм работает просто, берём отсортированный массив
    // сравниваем искомое число с тем, которое в середине массива
    // если оно меньше, то рассматриваем меньшую половину,
    // а если больше, то большую, где опять берём средний элемент
    // и вновь сравниваем и так пока не найдём нужный элемент.

    int first = 0;
    int last  = SIZE_ARRAY;
    int key = 2;  // Число, которое будем искать

    //
    while (first < last) {

        // Середина каждого диапазона определяется как первый элемент плюс
        // количество элементов пополам
        int average = first + (last - first) / 2;

        // Сравниваем выбранный в середине элемент с искомым элементом
        if (array[average] >= key)
            last = average; // Если элемент больше, то берём для рассмотрения
                            // половину массива меньше среднего элемента
        else
            first = average + 1; // Если нет, то большую

    }

    // Выведем найденный элемент и его индекс
    printf("index of %d = %d\n", array[last], last);

    return 0;
}

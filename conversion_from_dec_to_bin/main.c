/*
 * Copyright (C) 2020. GPL
 *
 * Written by Sadovskiy B. S.
 *
 * Права на программу (С) 2020. GPL
 *
 * Написана Садовским Б. С.
 *
 * Программа демонстрирует два способа перевода целых чисел из десятичной
 * в двоичную систему двумя способами
 * 1) алгоритм воспроизводит традиционный последовательный подход
 * 2) алгоритм использует битовые операции
 *
 * Подробнее:
 * https://ru.wikipedia.org/wiki/Двоичная_система_счисления
 *
 * 
 */

#include <stdio.h>
#include <stdlib.h>
#include <math.h>
#include <string.h>

/*
 * В общем случае для перевода из десятичной системы в двоичную
 * надо число делить на два и проверять остаток от деления.
 * Если остаток есть, пишем как единицу в последний разряд, а полученное число
 * делим дальше. И так пока не останется чисел для деления.
 * Возьмём число из примера в Википедии.
 * 19 / 2 = 9 целых или 9,5 с остатком значит пишем: 1
 *  9 / 2 = 4 целых или 4,5 с остатком значит пишем: 1
 *  4 / 2 = 2 целых без остатка значит пишем: 0
 *  2 / 2 = 1 целых без остатка значит пишем: 0
 *  1 / 2 = 0 целых или 0,5 с остатком значит пишем: 1
 * Итого: 19(dec) = 10011(bin)
 */

// Функция реализует последовательную логику как в примере выше
// dest_bin - указатель на строку куда будет складываться число в двоичной форме
// num_bits - размер выходной строки (число бит)
// src_dec - входное десятичное число, которое мы будем преобразовывать
void result_1(unsigned char *dest_bin,
              const size_t num_bits,
              const unsigned long long src_dec)
{
    unsigned long long dec = src_dec; // Сделаем локальную копию

    // Ограничение num_bits устанавливается типом данных src_dec
    // указанной при вызове, но не более SIZE_MAX
    for (size_t i = 0; i < num_bits; i++) {
        unsigned long remainder = dec % 2; // Узнаём, есть ли остаток от деления
        dec /= 2;  // Делим пополам

        // Если есть остаток, то ставим единицу, если нет, то ноль
        if (remainder)
            dest_bin[i] = '1';
        else
            dest_bin[i] = '0';

        // Для отслеживания хода вычислений
        if (dec > 0 || remainder)
            printf("%llu (%lu)\n", dec, remainder);
    }

    printf("\n");

    // Так как данные пишутся слева направо, у нас получилось первое
    // вычисленное значение в начале, а последнее в конце, то надо развернуть
    // наш массив
    for (size_t i = 0, j = num_bits - 1; i < (num_bits / 2); i++, j--) {
        char temp = dest_bin[i];
        dest_bin[i] = dest_bin[j];
        dest_bin[j] = temp;
    }
}

// Функция реализует побитовую логику для перевода в другую систему исчисления
// dest_bin - указатель на строку куда будет складываться число в двоичной форме
// num_bits - размер выходной строки (число бит)
// src_dec - входное десятичное число, которое мы будем преобразовывать
void result_2(unsigned char *dest_bin,
              const size_t num_bits,
              const unsigned long long src_dec)
{
    size_t i = 0;

    // Получим значение от степени двойки и поделим пополам
    // Это нужно, что бы получить первый бит в последовательности
    unsigned long long dec = powl(2, num_bits) / 2; // 2^8 = 256 / 2 = 128

    // Далее наглядно показано, что происходит с битами
    // Итерация 0: src_dec = 19 (0001 0011), dec = 8 (1000 0000)
    // Итерация 1: 10000000 >> 1 получаем 01000000 (64)
    // Итерация 2: 01000000 >> 1 получаем 00100000 (32)
    // Итерация 3: 00100000 >> 1 получаем 00010000 (16)
    // Итерация 4: 00010000 >> 1 получаем 00001000 (8)
    // Итерация 5: 00001000 >> 1 получаем 00000100 (4)
    // Итерация 6: 00000100 >> 1 получаем 00000010 (2)
    // Итерация 7: 00000010 >> 1 получаем 00000001 (1)
    // Итерация 8: 00000001 >> 1 получаем 00000000 (0) выходим из цикла
    for (; i < num_bits; dec >>= 1, i++) {

        // Итерация 0:     Итерация 1:    Итерация 2:    Итерация 3:
        // 10000000 - 128  01000000 - 64  00100000 - 32  00010000 - 16
        // 00010011 - 19   00010011 - 19  00010011 - 19  00010011 - 19
        //      =               =              =              =
        // 00000000 - 0    00000000 - 0   00000000 - 0   00010000 - 16

        // Итерация 4:    Итерация 5:     Итерация 6:    Итерация 7:
        // 00001000 - 8   00000100 - 4    00000010 - 2   00000000 - 1
        // 00010011 - 19  00010011 - 19   00010011 - 19  00010011 - 19
        //      =               =              =              =
        // 00000000 - 0   00000000 - 0    00000010 - 2   00000001 - 1
        unsigned long result_op_and = dec & src_dec;

        //                  dec == result_op_and
        // Итерация 0: 10000000 == 00000000 - не равны и мы пишем ноль
        // Итерация 1: 01000000 == 00000000 - не равны и мы пишем ноль
        // Итерация 2: 00100000 == 00000000 - не равны и мы пишем ноль
        // Итерация 3: 00010000 == 00010000 - равны и мы пишем единицу
        // Итерация 4: 00001000 == 00000000 - не равны и мы пишем ноль
        // Итерация 5: 00000100 == 00000000 - не равны и мы пишем ноль
        // Итерация 6: 00000010 == 00000010 - равны и мы пишем единицу
        // Итерация 7: 00000001 == 00000001 - равны и мы пишем единицу
        if (dec == result_op_and)
            dest_bin[i] = '1';
        else
            dest_bin[i] = '0';
    }
}


int main(void)
{
    // Переменной src_dec задаётся значение в десятичной форме,
    // которое надо перевести в двоичную.
    // Ограничения на размер!
    // Для примера возьмём 65534
    // 2^16 = 65536, но его нельзя использовать для типа unsigned short,
    // который имеет размер два байта и это число в него не влезет.
    // Типы данных для которых реализован перевод:
    // char (1 байт), short (2), int (4), long (8)

    // Используем пример из википедии с числом 19
    unsigned int src_dec = 19;
    size_t num_bytes = sizeof (src_dec); // Определим размер в байтах
    size_t num_bits = num_bytes * 8;     // И в битах

    // Завершающий ноль для строки dest_bin
    size_t end = 1;
    char   end_ch = '\0';

    // Массив куда будем складывать двоичные значения
    unsigned char *dest_bin_1 = malloc(num_bits + end);

    // Проверим, была ли выделена память
    if (!dest_bin_1) {
        printf("Error: Memory has not been allocated!");
        return EXIT_FAILURE;
    }

    // Вызовем первую функцию перевода в двоичную систему исчисления
    result_1(dest_bin_1, num_bits, src_dec);

    dest_bin_1[num_bits + end] = end_ch;

    // Выведем результат
    for (size_t i = 0; i < num_bits; ++i) {
        printf("%c", dest_bin_1[i]);
        if (!((i + 1) % 8))
            printf(" ");
    }

    printf("\n");

    // Освободим память
    free(dest_bin_1);

    /* ---------------------------------------------------------*/
    // Второй продолжение без комментариев, так как там всё повторяется

    unsigned char *dest_bin_2 = malloc(num_bits + end);

    if (!dest_bin_2) {
        printf("Error: Memory has not been allocated!");
        return EXIT_FAILURE;
    }

    // Вызовем вторую функцию перевода в двоичную систему исчисления
    result_2(dest_bin_2, num_bits, src_dec);

    dest_bin_2[num_bits + end] = end_ch;

    for (size_t i = 0; i < num_bits; ++i) {
        printf("%c", dest_bin_2[i]);
        if (!((i + 1) % 8))
            printf(" ");
    }

    printf("\n");

    free(dest_bin_2);

    return 0;
}
